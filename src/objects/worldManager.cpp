#include "worldManager.h"

#include "server.h"

// This creates a new QueueChunk with a pre-filled Client
QueueChunk::QueueChunk(Int3 position, Client* requestClient) {
    this->position = position;
    AddClient(requestClient);
}

// This adds a new Client to the Queued Chunk
void QueueChunk::AddClient(Client* requestClient) {
    requestedClients.push_back(requestClient);
}

// This adds a Chunk to the ChunkQueue
void WorldManager::AddChunkToQueue(int32_t x, int32_t z, Client* requestClient) {
    std::lock_guard<std::mutex> lock(queueMutex);  // Ensure thread safety

    auto hash = GetChunkHash(x, z);  // Compute hash

    if (chunkPositions.find(hash) != chunkPositions.end()) {
        // Chunk is already in the queue, no need to add it again
        // TODO: Add other requestClient to chunk!!
        return;
    }

    // Add to queue and track position
    chunkQueue.emplace(Int3{x, 0, z}, requestClient);
    chunkPositions.insert(hash);
}

// Returns if the ChunkQueue is empty
bool WorldManager::QueueIsEmpty() {
    return chunkQueue.empty();
}

// Sets the seed of both the WorldManager and the world
void WorldManager::SetSeed(int64_t seed) {
    this->seed = seed;
    world.seed = seed;
}

// Gets the current Seed
int64_t WorldManager::GetSeed() {
    return this->seed;
}

// This is run when the WorldManager is started.
// Its responsible for creating the Worker Threads and making them
// Generate Queued Chunks
void WorldManager::Run() {
    // Start worker threads
    for (int i = 0; i < workerCount; ++i) {
        workers.emplace_back(&WorldManager::WorkerThread, this);
    }

    // TODO: Add clean-up thread to remove unseen chunks
    while (Betrock::Server::Instance().IsAlive()) {
        GenerateQueuedChunks();
        std::this_thread::sleep_for(std::chrono::milliseconds(500)); // Sleep for half a second
    }

    // Stop workers
    queueCV.notify_all();

    for (auto& worker : workers) {
        if (worker.joinable()) worker.join();
    }
}

// This wakes up a worker thread so it starts generating a chunk
void WorldManager::GenerateQueuedChunks() {
    std::lock_guard<std::mutex> lock(queueMutex);
    queueCV.notify_one();  // Wake up a worker thread if it's sleeping
}

// Forces the generation of the passed Chunk Position,
// independent of any Worker Thread
void WorldManager::ForceGenerateChunk(int32_t x, int32_t z) {
    Generator generator;
    generator.PrepareGenerator(seed);
    GetChunk(x,z,generator);
}

// This is run by all the available Worker Threads
// To generate a chunk, if some are queued
void WorldManager::WorkerThread() {
    Generator generator;
    generator.PrepareGenerator(seed);

    while (Betrock::Server::Instance().IsAlive()) {
        QueueChunk cq;
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            queueCV.wait(lock, [this] { return !chunkQueue.empty() || !Betrock::Server::Instance().IsAlive(); });

            if (!Betrock::Server::Instance().IsAlive() && chunkQueue.empty()) return; // Exit thread when stopping

            cq = chunkQueue.front();
            chunkQueue.pop();
        }

        int64_t key = GetChunkHash(cq.position.x, cq.position.z);
        chunkPositions.erase(key);  // Remove from tracking set


		// Try to load chunk
        GetChunk(cq.position.x, cq.position.z,generator);

        std::scoped_lock lock(Betrock::Server::Instance().GetConnectedClientMutex());
        for (auto c : cq.requestedClients) {
            if (c) {
                c->AddNewChunk(cq.position);
            }
        }
    }
}

// This gets a chunk from the world if it isn't already in memory
// If a chunk file already exists for it, the file is just loaded into memory
// If the file is an old-format chunk, its loaded into memory and saved as a new-format chunk on the next save-cycle
// If the chunk doesn't yet exist on-disk, its generated by one of the worker threads.
void WorldManager::GetChunk(int32_t x, int32_t z, Generator &generator) {
    if (world.ChunkFileExists(x,z)) {
        world.LoadChunk(x,z);
    } else if (world.ChunkFileExists(x,z,OLD_CHUNK_FILE_EXTENSION)) {
        world.LoadOldChunk(x,z);
    } else {
        Chunk c = generator.GenerateChunk(x,z);
        world.AddChunk(x, z, c);
    }
}

// Sets the wm name
void WorldManager::SetName(std::string name) {
    this->name = name;
}

// Gets the wm name
std::string WorldManager::GetName() {
    return this->name;
}

// Used for creating the Minecraft Dimension Number, since the nether if -1, for example.
std::string ConvertIndexIntoExtra(int8_t worldId) {
    if (worldId == 0) {
        return "";
    }
    return "DIM" + std::to_string(worldId);
}

// This frees all unseen chunks from memory and saves all remaining chunks
void WorldManager::FreeAndSave() {
    // Remove all we can't see
    world.FreeUnseenChunks();
    // Save all that's left
    world.Save();
}

// Saves the world metadata to an NBT-format file
void WorldManager::SaveNbt() {
	auto &server = Betrock::Server::Instance();
	auto root = std::make_shared<CompoundTag>("");
	auto data = std::make_shared<CompoundTag>("Data");
	root->Put(data);

    Int3 spawn = Vec3ToInt3(server.GetSpawnPoint());

	data->Put(std::make_shared<LongTag>("RandomSeed",seed));
	data->Put(std::make_shared<IntTag>("SpawnY", spawn.y));
	data->Put(std::make_shared<IntTag>("rainTime", 87264));
	data->Put(std::make_shared<IntTag>("thunderTime", 26271));
	data->Put(std::make_shared<IntTag>("SpawnZ", spawn.z));
	data->Put(std::make_shared<IntTag>("SpawnX", spawn.x));
	data->Put(std::make_shared<ByteTag>("raining", 0));
	data->Put(std::make_shared<LongTag>("Time", server.GetServerTime()));
	data->Put(std::make_shared<ByteTag>("thundering", 0));
	data->Put(std::make_shared<IntTag>("version", 19132));
	data->Put(std::make_shared<LongTag>("LastPlayed", 1740410572431));
    std::string levelName = std::string(Betrock::GlobalConfig::Instance().Get("level-name"));
	data->Put(std::make_shared<StringTag>("LevelName", levelName));
	data->Put(std::make_shared<LongTag>("SizeOnDisk", 3956736));

	NbtWriteToFile(levelName + "/level.dat",root);
}

/*
void WorldManager::LoadNbt() {
	auto root = std::make_shared<CompoundTag>("");
	auto data = std::make_shared<CompoundTag>("Data");
	root->Put(data);

	data->Put(std::make_shared<LongTag>("RandomSeed",8703966663084738725));
	data->Put(std::make_shared<IntTag>("SpawnY", 64));
	data->Put(std::make_shared<IntTag>("rainTime", 87264));
	data->Put(std::make_shared<IntTag>("thunderTime", 26271));
	data->Put(std::make_shared<IntTag>("SpawnZ", -51));
	data->Put(std::make_shared<IntTag>("SpawnX", 63));
	data->Put(std::make_shared<ByteTag>("raining", 0));
	data->Put(std::make_shared<LongTag>("Time", 56719));
	data->Put(std::make_shared<ByteTag>("thundering", 0));
	data->Put(std::make_shared<IntTag>("version", 19132));
	data->Put(std::make_shared<LongTag>("LastPlayed", 1740410572431));
	data->Put(std::make_shared<StringTag>("LevelName", "world"));
	data->Put(std::make_shared<LongTag>("SizeOnDisk", 3956736));
}*/